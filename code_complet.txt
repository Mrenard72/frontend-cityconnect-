=== ./index.js ===
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);
=== ./App.js ===
import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import AppNavigator from './src/navigation/AppNavigator';
import * as Font from 'expo-font';
import { View, ActivityIndicator, Text } from 'react-native';

// Charger la police Fredoka One
const loadFonts = async () => {
  await Font.loadAsync({
    'FredokaOne': require('./assets/fonts/FredokaOne-Regular.ttf'),
  });
};

const App = () => {
  const [fontsLoaded, setFontsLoaded] = useState(false);

  useEffect(() => {
    loadFonts().then(() => setFontsLoaded(true));
  }, []);

  if (!fontsLoaded) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#2D2A6E" />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <AppNavigator />
    </NavigationContainer>
  );
};

export default App;
=== ./src/navigation/AppNavigator.js ===
import React, { useEffect, useState } from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { View, ActivityIndicator } from 'react-native';

// 📌 Import des écrans principaux de l'application
import HomeScreen from '../screens/HomeScreen';
import LoginScreen from '../screens/LoginScreen';
import RegisterScreen from '../screens/RegisterScreen';
import DashboardScreen from '../screens/DashboardScreen';
import ExploreScreen from '../screens/ExploreScreen';
import ProfileScreen from '../screens/ProfileScreen';
import MapScreen from '../screens/MapScreen';
import MessageScreen from '../screens/MessageScreen';
import MessageBoxScreen from '../screens/MessageBoxScreen';
import ActivityScreen from '../screens/ActivityScreen';

// 📌 Import des icônes pour la barre de navigation
import { Ionicons } from '@expo/vector-icons';

const Stack = createStackNavigator();
const Tab = createBottomTabNavigator();

// ✅ Nouvelle stack pour la gestion des messages
const MessageStack = () => {
  const MessageStackNav = createStackNavigator();

  return (
    <MessageStackNav.Navigator screenOptions={{ headerShown: false }}>
      {/* Liste des conversations */}
      <MessageStackNav.Screen name="MessageBox" component={MessageBoxScreen} />
      {/* Écran individuel pour une conversation */}
      <MessageStackNav.Screen name="Messaging" component={MessageScreen} />
    </MessageStackNav.Navigator>
  );
};


// ✅ Stack interne pour inclure `ExploreScreen` dans les onglets (et garder la navigation intacte)
const DashboardStack = () => {
  const DashboardStackNav = createStackNavigator();

  return (
    <DashboardStackNav.Navigator screenOptions={{ headerShown: false }}>
      <DashboardStackNav.Screen name="DashboardMain" component={DashboardScreen} />
      <DashboardStackNav.Screen name="Explore" component={ExploreScreen} />
      <DashboardStackNav.Screen name="Activity" component={ActivityScreen} />
    </DashboardStackNav.Navigator>
  );
};

// ✅ Barre de navigation en bas avec les onglets principaux
const BottomTabs = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarStyle: { backgroundColor: '#FFFFFF', height: 60 }, // 📌 Style de la barre d'onglets
        tabBarActiveTintColor: '#2D2A6E', // 📌 Couleur du texte actif
        tabBarInactiveTintColor: 'gray', // 📌 Couleur du texte inactif
        tabBarIcon: ({ color, size }) => {
          let iconName;
          if (route.name === 'Accueil') {
            iconName = 'home-outline'; // 🏠 Icône pour l'accueil
          } else if (route.name === 'Carte') {
            iconName = 'map-outline'; // Icône pour la carte
          } else if (route.name === 'Messagerie') {
            iconName = 'chatbubble-outline'; // 💬 Icône pour la messagerie
          } else if (route.name === 'Profil') {
            iconName = 'person-outline'; // 👤 Icône pour le profil
          }
          return <Ionicons name={iconName} size={size} color={color} />;
        },
      })}
    > 
    {/* 📌 Onglet Accueil (contient aussi ExploreScreen via DashboardStack) */}
      <Tab.Screen name="Accueil" component={DashboardStack} />
        {/* Onglet Carte */}
      <Tab.Screen name="Carte" component={MapScreen} />
      {/* 💬 Onglet Messagerie */}
      <Tab.Screen name="Messagerie" component={MessageStack} />
      {/* 👤 Onglet Profil */}
      <Tab.Screen name="Profil" component={ProfileScreen} />
    </Tab.Navigator>
  );
};

// ✅ Stack principal avec gestion de l'authentification
const AppNavigator = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(null); // 📌 État pour suivre la connexion de l'utilisateur

  useEffect(() => {
    const checkLoginStatus = async () => {
      try {
        const token = await AsyncStorage.getItem('token'); // 🔑 Vérification du token utilisateur
        if (!token) {
          setIsLoggedIn(false); // 🚫 Pas de token → utilisateur non connecté
          return;
        }

         // 🔍 Vérifier si le token est valide en appelant l'API backend
        const response = await fetch('https://backend-city-connect.vercel.app/auth/profile', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          setIsLoggedIn(true);  // ✅ Le token est valide → utilisateur connecté
        } else {
          await AsyncStorage.removeItem('token'); // 🚫 Supprimer un token invalide
          setIsLoggedIn(false);
        }
      } catch (error) {
        console.error("Erreur lors de la vérification du token:", error);
        setIsLoggedIn(false);
      }
    };
    
    checkLoginStatus();
  }, []);

  // ⏳ Si l'état de connexion n'est pas encore déterminé, afficher un **loader**
  if (isLoggedIn === null) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#2D2A6E" /> 
      </View>
    );
  }
        // ✅ Gestion de la navigation selon l'état de connexion
  return (
    <Stack.Navigator>
      {isLoggedIn ? (
        <>
         {/* 🏠 Si l'utilisateur est connecté, afficher le dashboard avec les onglets */}
          <Stack.Screen name="Dashboard" component={BottomTabs} options={{ headerShown: false }} />
          
        </>
      ) : (
        <>
          {/* 🚪 Si l'utilisateur N'EST PAS connecté, afficher les écrans d'authentification */}
          <Stack.Screen name="Home" component={HomeScreen} options={{ headerShown: false }} />
          <Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
          <Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
          
          <Stack.Screen name="Dashboard" component={BottomTabs} options={{ headerShown: false }} />
          <Stack.Screen name="Explore" component={ExploreScreen} options={{ headerShown: false }} />
          <Stack.Screen name="Activity" component={ActivityScreen} options={{ headerShown: false }} />
          
        </>
      )}
    </Stack.Navigator>

    
  );
};

export default AppNavigator;
=== ./src/screens/RegisterScreen.js ===
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, StyleSheet, ImageBackground, Image } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const RegisterScreen = ({ navigation }) => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');

  const handleRegister = async () => {
    if (password !== confirmPassword) {
      alert("Les mots de passe ne correspondent pas !");
      return;
    }

    try {
      const response = await fetch('https://backend-city-connect.vercel.app/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, email, password }),
      });

      const data = await response.json();
      console.log("Réponse du backend :", data);
      if (response.ok) {
        await AsyncStorage.setItem('token', data.token);
        navigation.reset({
          index: 0,
          routes: [{ name: 'Dashboard' }],
        });
      } else {
        alert(data.message);
      }
    } catch (error) {
      console.error('Erreur lors de l’inscription:', error);
    }
  };

  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <View style={styles.header}>
        <View style={styles.headerCenter}>
          <Image source={require('../../assets/logo.png')} style={styles.logo} />
          <Text style={styles.title}>CityConnect</Text>
        </View>
      </View>
      
      <View style={styles.container}>
        <Text style={styles.subtitle}>Inscription</Text>
        <TextInput 
          placeholder="Nom d'utilisateur" 
          style={styles.input} 
          value={username} 
          onChangeText={setUsername} 
        />
        <TextInput 
          placeholder="Email" 
          style={styles.input} 
          value={email} 
          onChangeText={setEmail} 
        />
        <TextInput 
          placeholder="Mot de passe" 
          style={styles.input} 
          secureTextEntry 
          value={password} 
          onChangeText={setPassword} 
        />
        <TextInput 
          placeholder="Confirmer le mot de passe" 
          style={styles.input} 
          secureTextEntry 
          value={confirmPassword} 
          onChangeText={setConfirmPassword} 
        />
        <TouchableOpacity style={styles.button} onPress={handleRegister}>
          <Text style={styles.buttonText}>S'inscrire</Text>
        </TouchableOpacity>

        <TouchableOpacity onPress={() => navigation.navigate('Login')}>
          <Text style={styles.linkText}>Déjà un compte ? Connecte-toi</Text>
        </TouchableOpacity>
      </View>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
    justifyContent: 'flex-start',
    alignItems: 'center',
  },
  header: {
    width: '100%',
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 40,
  },
  headerCenter: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  logo: {
    width: 30,
    height: 30,
    marginRight: 10,
  },
  title: {
    fontSize: 18,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
  },
  container: {
    width: '90%',
    alignItems: 'center',
    marginTop: 20,
  },
  subtitle: {
    fontSize: 22,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 20,
  },
  input: {
    width: '100%',
    padding: 12,
    marginVertical: 10,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 10,
    backgroundColor: 'rgba(255,255,255,0.8)',
    textAlign: 'center',
    fontSize: 16,
    fontWeight: 'bold',
    color: '#999',
  },
  button: {
    backgroundColor: '#2D2A6E',
    padding: 15,
    borderRadius: 10,
    width: '100%',
    alignItems: 'center',
    marginTop: 20,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontFamily: 'FredokaOne',
  },
  linkText: {
    marginTop: 15,
    color: '#2D2A6E',
    fontFamily: 'FredokaOne',
  },
});

export default RegisterScreen;
=== ./src/screens/ProfileScreen.js ===
import React, { useEffect, useState } from 'react';
import { 
  View, Text, Image, TouchableOpacity, StyleSheet, 
  Alert, ImageBackground 
} from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import Header from '../components/Header';
import AsyncStorage from '@react-native-async-storage/async-storage'; 

// 📌 Écran du profil utilisateur
const ProfileScreen = ({ navigation }) => {
  // ✅ États pour stocker les données utilisateur
  const [profileImage, setProfileImage] = useState(null);
  const [userName, setUserName] = useState(''); // 🔹 Stocke le nom de l'utilisateur

  // 🚀 Fonction pour récupérer le profil utilisateur
  useEffect(() => {
    const fetchUserProfile = async () => {
      try {
        const token = await AsyncStorage.getItem('token'); // ✅ Récupère le token stocké
        if (!token) {
          navigation.reset({ index: 0, routes: [{ name: 'Login' }] }); // 🔄 Redirection si pas de token
          return;
        }

        const response = await fetch('https://backend-city-connect.vercel.app/auth/profile', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });

        const data = await response.json();
        if (response.ok) {
          setUserName(data.username); // ✅ Met à jour le nom de l'utilisateur
        } else {
          console.log("Erreur récupération profil :", data.message);
          await AsyncStorage.removeItem('token'); // ❌ Supprime le token si erreur
          navigation.reset({ index: 0, routes: [{ name: 'Login' }] });
        }
      } catch (error) {
        console.error("Erreur lors de la récupération du profil :", error);
      }
    };

    fetchUserProfile();
  }, []);

  // 🚀 Fonction pour gérer la déconnexion
  const handleLogout = async () => {
    try {
      await AsyncStorage.removeItem('token'); // ✅ Supprime le token
      console.log("Déconnexion réussie !");
      navigation.reset({
        index: 0,
        routes: [{ name: 'Home' }],
      });
    } catch (error) {
      console.error("Erreur lors de la déconnexion :", error);
    }
  };

  // 📷 Fonction pour ouvrir la galerie et choisir une photo
  const handleChoosePhoto = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images, 
      allowsEditing: true,
      aspect: [1, 1], 
      quality: 1, 
    });

    if (!result.canceled) {
      setProfileImage(result.assets[0].uri);
    }
  };

  // 📸 Fonction pour afficher une alerte et changer la photo de profil
  const handleProfileImagePress = () => {
    Alert.alert(
      'Changer de photo de profil',
      '',
      [
        { text: 'Annuler', style: 'cancel' },
        { text: 'Changer', onPress: handleChoosePhoto },
      ]
    );
  };

  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <Header />
      
      <View style={styles.container}>
        {/* 📸 Section de la photo de profil */}
        <View style={styles.imageContainer}>
          <TouchableOpacity onPress={handleProfileImagePress} style={styles.touchable}>
            {profileImage ? (
              <Image source={{ uri: profileImage }} style={styles.profileImage} />
            ) : (
              <Text style={styles.addPhotoText}>Changer de photo</Text>
            )}
          </TouchableOpacity>
        </View>

        {/* ✅ Affichage dynamique du nom utilisateur */}
        <Text style={styles.userName}>{userName ? userName : "Chargement..."}</Text>

        {/* 📌 Boutons des différentes sections */}
        <TouchableOpacity style={styles.button} activeOpacity={0.8}>
          <Text style={styles.textButton}>Mes services</Text>
        </TouchableOpacity>

        <TouchableOpacity style={styles.button} activeOpacity={0.8}>
          <Text style={styles.textButton}>Mes sorties</Text>
        </TouchableOpacity>

        <TouchableOpacity onPress={() => navigation.navigate('Info')} style={styles.button} activeOpacity={0.8}>
          <Text style={styles.textButton}>Mes infos</Text>
        </TouchableOpacity>

        {/* 🔴 Bouton de déconnexion */}
        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Text style={styles.logoutButtonText}>Déconnexion</Text>
        </TouchableOpacity>
      </View>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'flex-start',
    paddingTop: 180,
  },
  imageContainer: {
    width: 150,
    height: 150,
    borderRadius: 80,
    backgroundColor: '#ddd',
    justifyContent: 'center',
    alignItems: 'center',
    overflow: 'hidden',
    marginBottom: 20,
    borderWidth: 4,
    borderColor: '#20135B',
  },
  touchable: {
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  profileImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  addPhotoText: {
    color: '#888',
    fontSize: 16,
  },
  userName: {
    fontSize: 22, // 📌 Augmenté pour plus de lisibilité
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 15,
  },
  button: {
    backgroundColor: '#20135B',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    marginVertical: 10,
    width: '80%',
    alignItems: 'center',
  },
  textButton: {
    color: '#FFFFFF',
    fontSize: 20,
    fontFamily: 'FredokaOne',
  },
  logoutButton: {
    backgroundColor: '#E53935',
    paddingVertical: 12,
    paddingHorizontal: 20,
    borderRadius: 8,
    width: '80%',
    alignItems: 'center',
    position: 'absolute',
    bottom: 20,
  },
  logoutButtonText: {
    color: '#FFFFFF',
    fontSize: 20,
    fontFamily: 'FredokaOne',
  },
});

export default ProfileScreen;=== ./src/screens/MapScreen.js ===
import React, { useState, useEffect, useCallback } from 'react';
import { 
  View, Text, StyleSheet, Alert, ActivityIndicator,
  TextInput, TouchableOpacity, KeyboardAvoidingView, Platform, Modal
} from 'react-native';
import MapView, { Marker } from 'react-native-maps';
import * as Location from 'expo-location';
import { useFocusEffect } from '@react-navigation/native';

// Ajustez l'URL de votre backend
const BASE_URL = 'https://backend-city-connect.vercel.app';

export default function MapScreen({ route }) {
  const { 
    filter,
    userLocation, // pour aroundMe, activity, createActivity
    locality,     // pour byLocality { name, latitude, longitude }
    category,     // pour activity
    // Ou lat/ lon / region si vous les transmettez en plus
  } = route.params || {};

  // Région par défaut (Paris)
  const defaultRegion = {
    latitude: 48.8566,
    longitude: 2.3522,
    latitudeDelta: 0.01,
    longitudeDelta: 0.01,
  };

  const [region, setRegion] = useState(defaultRegion);
  const [loading, setLoading] = useState(false);

  // -- ACTIVITY MODE --
  const [activities, setActivities] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState(
    filter === 'activity' ? category : null
  );

  // -- BY LOCALITY MODE --
  // On affiche un champ de saisie pour taper d'autres coordonnées
  const [showInput, setShowInput] = useState(false);
  const [latitudeInput, setLatitudeInput] = useState('');
  const [longitudeInput, setLongitudeInput] = useState('');

  // -- CREATE ACTIVITY MODE --
  const [isCreateModalVisible, setIsCreateModalVisible] = useState(false);
  const [newActivityCoords, setNewActivityCoords] = useState(null);
  const [newActivityTitle, setNewActivityTitle] = useState('');
  const [newActivityDescription, setNewActivityDescription] = useState('');
  const [activitiesCreated, setActivitiesCreated] = useState([]); 
  // vous pouvez les mélanger dans 'activities' si vous voulez tout afficher ensemble

  /** 
   * On utilise useFocusEffect pour exécuter la logique
   * chaque fois que l'écran redevient actif,
   * selon la valeur de "filter".
   */
  useFocusEffect(
    useCallback(() => {
      if (filter === 'aroundMe') {
        // Récupérer la position de l'utilisateur
        getUserLocation();
        setShowInput(false);
      }
      else if (filter === 'byLocality') {
        // Afficher les inputs, et centrer la carte selon route.params
        handleByLocality();
        setShowInput(true);
      }
      else if (filter === 'activity') {
        // Centrer sur userLocation si dispo, sinon getUserLocation
        handleActivityMode();
        setShowInput(false);
      }
      else if (filter === 'createActivity') {
        // On se centre sur userLocation ou getUserLocation
        handleCreateActivityMode();
        setShowInput(false);
      }
    }, [filter])
  );

  // --------------------------
  // FONCTIONS PAR MODE
  // --------------------------

  /** aroundMe / fallback */
  const getUserLocation = async () => {
    setLoading(true);
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permission refusée', 'Activez la localisation pour voir votre position.');
        setLoading(false);
        return;
      }
      const location = await Location.getCurrentPositionAsync({});
      setRegion({
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01,
      });
    } catch (error) {
      Alert.alert('Erreur', 'Impossible d’obtenir votre position.');
      console.log(error);
    }
    setLoading(false);
  };

  /** byLocality */
  const handleByLocality = () => {
    if (locality && locality.latitude && locality.longitude) {
      // On se centre sur la localité
      setRegion({
        latitude: locality.latitude,
        longitude: locality.longitude,
        latitudeDelta: 0.05,
        longitudeDelta: 0.05,
      });
    }
    else if (route.params?.region) {
      // S'il y a un paramètre region
      setRegion(route.params.region);
    }
    else if (route.params?.latitude && route.params?.longitude) {
      // S'il y a lat / lon
      setRegion({
        latitude: route.params.latitude,
        longitude: route.params.longitude,
        latitudeDelta: 0.05,
        longitudeDelta: 0.05,
      });
    }
    else {
      // Sinon on reset à Paris
      setRegion(defaultRegion);
      setLatitudeInput('');
      setLongitudeInput('');
    }
  };

  /** activity */
  const handleActivityMode = async () => {
    if (userLocation) {
      // On se centre sur la localisation transmise
      setRegion({
        latitude: userLocation.latitude,
        longitude: userLocation.longitude,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01,
      });
    } else {
      // Sinon, fallback
      await getUserLocation();
    }
    // Charger la catégorie initiale si existante
    if (selectedCategory) {
      fetchActivities(selectedCategory);
    }
  };

  /** createActivity */
  const handleCreateActivityMode = async () => {
    if (userLocation) {
      setRegion({
        latitude: userLocation.latitude,
        longitude: userLocation.longitude,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01,
      });
    } else {
      await getUserLocation();
    }
  };

  // --------------------------
  // GESTION DES ACTIVITES
  // --------------------------
  const fetchActivities = async (cat) => {
    try {
      setLoading(true);
      const response = await fetch(`${BASE_URL}/activities?category=${cat}`);
      const data = await response.json();
      setActivities(data);
      setLoading(false);
    } catch (error) {
      console.log("Erreur lors du chargement des activités :", error);
      setLoading(false);
    }
  };

  // --------------------------
  // Saisie manuelle (byLocality)
  // --------------------------
  const handleRecenterMap = () => {
    const lat = parseFloat(latitudeInput);
    const lon = parseFloat(longitudeInput);
    if (isNaN(lat) || isNaN(lon)) {
      Alert.alert('Coordonnées invalides', 'Veuillez saisir des valeurs numériques.');
      return;
    }
    setRegion({
      latitude: lat,
      longitude: lon,
      latitudeDelta: 0.05,
      longitudeDelta: 0.05,
    });
  };

  // --------------------------
  // CREATE ACTIVITY
  // --------------------------
  const handleMapPress = (event) => {
    if (filter === 'createActivity') {
      const coords = event.nativeEvent.coordinate;
      setNewActivityCoords(coords);
      setIsCreateModalVisible(true);
    }
  };

  const handleCreateActivity = async () => {
    if (!newActivityCoords || !newActivityTitle.trim()) {
      Alert.alert("Champs manquants", "Veuillez saisir un titre et cliquer sur la carte.");
      return;
    }
    try {
      const resp = await fetch(`${BASE_URL}/activities`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: newActivityTitle,
          description: newActivityDescription,
          latitude: newActivityCoords.latitude,
          longitude: newActivityCoords.longitude,
          // Ajoutez un "creator" si besoin (ex: userId)
        }),
      });

      if (!resp.ok) {
        const errorData = await resp.json();
        Alert.alert("Erreur création", errorData.message || "Impossible de créer l'activité");
        return;
      }
      const created = await resp.json();
      // On l'ajoute à la liste
      setActivitiesCreated([...activitiesCreated, created]);
      // Optionnel : vous pouvez aussi l'ajouter à 'activities' si vous voulez la voir en même temps
      // setActivities([...activities, created]);

      setIsCreateModalVisible(false);
      setNewActivityCoords(null);
      setNewActivityTitle('');
      setNewActivityDescription('');
      Alert.alert("Activité créée", "Votre activité a bien été créée !");
    } catch (err) {
      console.log("Erreur création activité:", err);
      Alert.alert("Erreur", "Impossible de créer l'activité.");
    }
  };

  // --------------------------
  // RENDER
  // --------------------------
  if (loading) {
    return <ActivityIndicator size="large" color="#2D2A6E" style={styles.loader} />;
  }

  // On combine "activities" et "activitiesCreated" pour l'affichage des marqueurs,
  // si vous le souhaitez.
  const allMarkers = [...activities, ...activitiesCreated];

  return (
    <View style={styles.container}>
      {/* Champs de saisie si mode byLocality */}
      {showInput && (
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'} 
          style={styles.inputContainer}
        >
          <TextInput
            style={styles.input}
            placeholder="Latitude"
            keyboardType="numeric"
            value={latitudeInput}
            onChangeText={setLatitudeInput}
          />
          <TextInput
            style={styles.input}
            placeholder="Longitude"
            keyboardType="numeric"
            value={longitudeInput}
            onChangeText={setLongitudeInput}
          />
          <TouchableOpacity style={styles.button} onPress={handleRecenterMap}>
            <Text style={styles.buttonText}>OK</Text>
          </TouchableOpacity>
        </KeyboardAvoidingView>
      )}

      <MapView
        style={styles.map}
        region={region}
        onPress={handleMapPress} // Si mode createActivity => ouvre la modale
      >
        {/* Marqueurs pour "activity" ou d'autres modes si on veut afficher tout */}
        {filter === 'activity' && activities.map((act) => (
          <Marker
            key={act._id}
            coordinate={{ latitude: act.latitude, longitude: act.longitude }}
            title={act.title}
            description={act.description}
          />
        ))}

        {/* Marqueurs des activités créées en mode "createActivity" */}
        {filter === 'createActivity' && activitiesCreated.map((act) => (
          <Marker
            key={act._id}
            coordinate={{ latitude: act.latitude, longitude: act.longitude }}
            title={act.title}
            description={act.description}
          />
        ))}

        {/* Marqueur principal : position "courante" ou localité */}
        <Marker
          coordinate={{ latitude: region.latitude, longitude: region.longitude }}
          title={
            filter === 'byLocality' && locality
              ? locality.name
              : 'Position actuelle'
          }
        />
      </MapView>

      {/* Barre de catégories si mode "activity" */}
      {filter === 'activity' && (
        <View style={styles.categoryBar}>
          {['Sport', 'Culturel', 'Sorties', 'Culinaire'].map((cat) => (
            <TouchableOpacity
              key={cat}
              style={[
                styles.categoryButton,
                selectedCategory === cat && styles.activeButton,
              ]}
              onPress={() => {
                setSelectedCategory(cat);
                fetchActivities(cat);
              }}
            >
              <Text style={styles.categoryText}>{cat}</Text>
            </TouchableOpacity>
          ))}
        </View>
      )}

      {/* Modale pour création d'activité si mode "createActivity" */}
      <Modal
        transparent={true}
        visible={isCreateModalVisible}
        animationType="slide"
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>Créer une activité</Text>
            <TextInput
              style={styles.modalInput}
              placeholder="Titre"
              value={newActivityTitle}
              onChangeText={setNewActivityTitle}
            />
            <TextInput
              style={[styles.modalInput, { height: 70 }]}
              multiline
              placeholder="Description"
              value={newActivityDescription}
              onChangeText={setNewActivityDescription}
            />

            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.button, { backgroundColor: '#999', marginRight: 10 }]}
                onPress={() => {
                  setIsCreateModalVisible(false);
                  setNewActivityCoords(null);
                  setNewActivityTitle('');
                  setNewActivityDescription('');
                }}
              >
                <Text style={styles.buttonText}>Annuler</Text>
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.button, { backgroundColor: '#2D2A6E' }]}
                onPress={handleCreateActivity}
              >
                <Text style={styles.buttonText}>Créer</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

// --- STYLES ---
const styles = StyleSheet.create({
  container: { flex: 1 },
  map: { flex: 1 },
  loader: { flex: 1, justifyContent: 'center', alignItems: 'center' },
  // Saisie byLocality
  inputContainer: {
    position: 'absolute',
    top: Platform.OS === 'ios' ? 80 : 60,
    left: 10,
    right: 10,
    flexDirection: 'row',
    backgroundColor: '#FFF',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 8,
    borderRadius: 10,
    zIndex: 10,
    shadowColor: '#000',
    shadowOpacity: 0.2,
    shadowRadius: 4,
  },
  input: {
    flex: 1,
    padding: 10,
    borderWidth: 1,
    borderColor: '#CCC',
    borderRadius: 8,
    backgroundColor: '#FFF',
    marginRight: 10,
  },
  button: {
    backgroundColor: '#2D2A6E',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 8,
  },
  buttonText: { 
    color: '#fff',
    fontWeight: 'bold', 
    textAlign: 'center',
  },
  // Barre des catégories
  categoryBar: {
    position: 'absolute',
    bottom: 20,
    left: 10,
    right: 10,
    flexDirection: 'row',
    justifyContent: 'space-around',
    backgroundColor: 'rgba(255,255,255,0.9)',
    paddingVertical: 10,
    borderRadius: 10,
  },
  categoryButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 5,
    backgroundColor: '#ccc',
  },
  activeButton: { backgroundColor: '#2D2A6E' },
  categoryText: {
    color: '#fff',
    fontWeight: 'bold',
  },
  // Modal création
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContainer: {
    width: '85%',
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 20,
  },
  modalTitle: {
    fontSize: 18,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 10,
  },
  modalInput: {
    borderWidth: 1,
    borderColor: '#CCC',
    borderRadius: 8,
    padding: 10,
    marginVertical: 8,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    marginTop: 10,
  },
});
=== ./src/screens/ExploreScreen.js ===
import React, { useState } from 'react';
import { 
  View, Text, TouchableOpacity, StyleSheet, ImageBackground, 
  Alert, TextInput, Modal, Button
} from 'react-native';
import * as Location from 'expo-location';
import Header from '../components/Header';

const ExploreScreen = ({ navigation }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [showModal, setShowModal] = useState(false);
  const [showDateModal, setShowDateModal] = useState(false);
  const [selectedDate, setSelectedDate] = useState('');

  // 📍 Obtenir la position actuelle et naviguer vers MapScreen avec le filtre 'aroundMe'
  const handleLocationSearch = async () => {
    let { status } = await Location.requestForegroundPermissionsAsync();
    if (status !== 'granted') {
      Alert.alert("Permission refusée", "L'accès à la localisation est nécessaire pour cette fonctionnalité.");
      return;
    }
    try {
      let userLocation = await Location.getCurrentPositionAsync({});
      const { latitude, longitude } = userLocation.coords;
      navigation.navigate('Carte', { 
        filter: 'aroundMe', 
        latitude, 
        longitude,
        region: { latitude, longitude, latitudeDelta: 0.05, longitudeDelta: 0.05 }
      });
    } catch (error) {
      Alert.alert("Erreur", "Impossible d’obtenir votre position.");
    }
  };

  // 🔎 Ouvrir la modale pour saisir une ville dès l'appui sur "Par localisation"
  const handleCitySearch = () => {
    setShowModal(true);
  };

  // 🔎 Valider la saisie d'une ville grâce au géocodage et naviguer vers MapScreen
  const handleCitySearchSubmit = async () => {
    if (searchQuery.trim() === '') {
      Alert.alert("Erreur", "Veuillez entrer un nom de ville.");
      return;
    }
    try {
      const geocodeResults = await Location.geocodeAsync(searchQuery);
      if (geocodeResults && geocodeResults.length > 0) {
        const { latitude, longitude } = geocodeResults[0];
        console.log("Ville trouvée :", searchQuery, "Coordonnées :", latitude, longitude);
        setShowModal(false);
        // Transmettre à MapScreen la région calculée ainsi que les coordonnées individuelles
        navigation.navigate('Carte', { 
          filter: 'byLocality', 
          city: searchQuery, 
          latitude, 
          longitude,
          region: { latitude, longitude, latitudeDelta: 0.05, longitudeDelta: 0.05 }
        });
      } else {
        Alert.alert("Erreur", "Aucune ville trouvée pour ce nom.");
      }
    } catch (error) {
      console.error(error);
      Alert.alert("Erreur", "Impossible de géocoder cette ville.");
    }
  };

  // 📅 Ouvrir la modale pour entrer une date
  const handleDateSearch = () => {
    setShowDateModal(true);
  };

  // 📅 Valider la date et naviguer vers MapScreen avec le filtre 'date'
  const validateDateAndNavigate = () => {
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(selectedDate)) {
      Alert.alert("Format incorrect", "Veuillez entrer une date au format YYYY-MM-DD");
      return;
    }
    setShowDateModal(false);
    navigation.navigate('Carte', { filter: 'date', selectedDate });
  };

  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <Header />
      <View style={styles.container}>
        <Text style={styles.title}>Explorer la ville</Text>

        {/* 📍 Autour de moi */}
        <TouchableOpacity style={styles.filterButton} onPress={handleLocationSearch}>
          <Text style={styles.buttonText}>Autour de moi</Text>
        </TouchableOpacity>

        {/* 🔎 Par localisation */}
        <TouchableOpacity style={styles.filterButton} onPress={handleCitySearch}>
          <Text style={styles.buttonText}>Par localisation</Text>
        </TouchableOpacity>

        {/* 🎭 Par activité */}
        <TouchableOpacity style={styles.filterButton} onPress={() => navigation.navigate('Activity')}>
          <Text style={styles.buttonText}>Par activité</Text>
        </TouchableOpacity>

        {/* 📅 Par date */}
        <TouchableOpacity style={styles.filterButton} onPress={handleDateSearch}>
          <Text style={styles.buttonText}>Par date</Text>
        </TouchableOpacity>
      </View>

      {/* 🔎 Modal pour la recherche de ville */}
      <Modal visible={showModal} transparent={true} animationType="slide">
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Rechercher une ville</Text>
            <TextInput 
              style={styles.searchInput}
              placeholder="Entrez une ville..."
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
            <View style={styles.modalButtons}>
              <Button title="Annuler" onPress={() => setShowModal(false)} />
              <Button title="Rechercher" onPress={handleCitySearchSubmit} />
            </View>
          </View>
        </View>
      </Modal>

      {/* 📅 Modal pour entrer une date */}
      <Modal visible={showDateModal} transparent={true} animationType="slide">
        <View style={styles.modalContainer}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Sélectionner une date</Text>
            <TextInput
              style={styles.searchInput}
              placeholder="YYYY-MM-DD"
              keyboardType="numeric"
              value={selectedDate}
              onChangeText={setSelectedDate}
            />
            <View style={styles.modalButtons}>
              <Button title="Annuler" onPress={() => setShowDateModal(false)} />
              <Button title="Valider" onPress={validateDateAndNavigate} />
            </View>
          </View>
        </View>
      </Modal>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
    alignItems: 'center',
  },
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    width: '90%',
  },
  title: {
    fontSize: 26,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 20,
    textAlign: 'center',
  },
  filterButton: {
    backgroundColor: '#2D2A6E',
    padding: 15,
    borderRadius: 10,
    width: '80%',
    alignItems: 'center',
    justifyContent: 'center',
    marginVertical: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontFamily: 'FredokaOne',
  },
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  modalContent: {
    width: '80%',
    backgroundColor: '#FFF',
    padding: 20,
    borderRadius: 10,
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: 18,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 10,
    textAlign: 'center',
  },
  searchInput: {
    width: '100%',
    padding: 12,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 10,
    backgroundColor: 'rgba(255,255,255,0.9)',
    textAlign: 'center',
    fontSize: 16,
    fontFamily: 'FredokaOne',
    marginBottom: 15,
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
});

export default ExploreScreen;
=== ./src/screens/MessageBoxScreen.js ===
import React from 'react';
import { 
  View, Text, TouchableOpacity, FlatList, StyleSheet 
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import Header from '../components/Header';

const MessageBoxScreen = () => {
  const navigation = useNavigation();

  // Liste des conversations (données statiques pour l'exemple)
  const conversations = [
    { 
      id: '1', 
      name: 'Sortie au Louvre', 
      lastMessage: 'À bientôt !', 
      time: '10:30',
      exampleMessages: [
        { id: '1', text: 'Bonjour, prêts pour la sortie ?', sender: 'other', senderName: 'Alice', time: '09:00' },
        { id: '2', text: 'Oui, à quelle heure on se rejoint ?', sender: 'me', senderName: 'Moi', time: '09:10' },
        { id: '3', text: 'Disons 14h devant l\'entrée principale.', sender: 'other', senderName: 'Alice', time: '09:15' },
      ],
    },
    { 
      id: '2', 
      name: 'Bar le 13', 
      lastMessage: 'D\'accord, merci.', 
      time: '09:45',
      exampleMessages: [
        { id: '1', text: 'Salut, c\'est toujours bon pour ce soir ?', sender: 'other', senderName: 'Tom', time: '18:00' },
        { id: '2', text: 'Oui, à quelle heure ?', sender: 'me', senderName: 'Moi', time: '18:05' },
        { id: '3', text: '20h au Bar le 13.', sender: 'other', senderName: 'Tom', time: '18:10' },
      ],
    },
  ];

  // Fonction pour naviguer vers la conversation
  const handleOpenConversation = (conversation) => {
    navigation.navigate('Messaging', { 
      conversationId: conversation.id, 
      conversationName: conversation.name, 
      exampleMessages: conversation.exampleMessages,
    });
  };

  return (
    <View style={styles.container}>
      <Header />
      <FlatList
        data={conversations}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={styles.conversationItem} 
            onPress={() => handleOpenConversation(item)}
          >
            <View style={styles.conversationContent}>
              <Text style={styles.conversationName}>{item.name}</Text>
              <Text style={styles.lastMessage}>{item.lastMessage}</Text>
            </View>
            <Text style={styles.time}>{item.time}</Text>
          </TouchableOpacity>
        )}
        contentContainerStyle={styles.listContainer}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  listContainer: {
    padding: 10,
    paddingTop: 140,
  },
  conversationItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 15,
    paddingHorizontal: 10,
    backgroundColor: '#fff',
    borderRadius: 10,
    marginBottom: 10,
    elevation: 2, // Pour une légère ombre
  },
  conversationContent: {
    flex: 1,
  },
  conversationName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  lastMessage: {
    fontSize: 14,
    color: '#777',
    marginTop: 5,
  },
  time: {
    fontSize: 12,
    color: '#999',
  },
});

export default MessageBoxScreen;
=== ./src/screens/DashboardScreen.js ===
import React from 'react';
import { 
  View, Text, TouchableOpacity, StyleSheet, Image, ImageBackground 
} from 'react-native';

// 📌 Écran du tableau de bord (DashboardScreen)
const DashboardScreen = ({ navigation }) => {
  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <View style={styles.container}>
        {/* 🏙️ Logo de l'application */}
        <Image source={require('../../assets/logo.png')} style={styles.logo} />
        <Text style={styles.title}>Tableau de bord</Text>

        {/* 📌 Carte "J'explore" → Navigue vers `ExploreScreen` */}
        <TouchableOpacity style={styles.card} onPress={() => navigation.navigate('Explore')}>
          <Image source={require('../../assets/explore.jpg')} style={styles.cardImage} />
          <View style={styles.overlay}>
            <Text style={styles.cardText}>J'explore</Text>
          </View>
        </TouchableOpacity>

        {/* 📌 Carte "Je fais découvrir" → Navigue vers `DiscoverScreen` */}
        <TouchableOpacity style={styles.card} onPress={() => {
            navigation.navigate('Carte', {
              filter: 'createActivity',
              // vous pouvez aussi passer userLocation, userId, etc. si besoin
            });
          }}>
          <Image source={require('../../assets/discover.jpg')} style={styles.cardImage} />
          <View style={styles.overlay}>
            <Text style={styles.cardText}>Je fais découvrir</Text>
          </View>
        </TouchableOpacity>
      </View>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    alignItems: 'center',
  },
  logo: {
    width: 120,
    height: 120,
    marginBottom: 20,
  },
  title: {
    fontSize: 26,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 20,
  },
  card: {
    width: '100%',
    height: 150,
    borderRadius: 10,
    overflow: 'hidden',
    marginBottom: 20,
  },
  cardImage: {
    width: '100%',
    height: '100%',
    position: 'absolute',
  },
  cardText: {
    fontSize: 22,
    fontFamily: 'FredokaOne',
    color: 'white',
    textAlign: 'center',
    marginTop: 'auto',
    marginBottom: 10,
    paddingVertical: 5,
  },
  logoutButton: {
    backgroundColor: '#E53935',
    padding: 15,
    borderRadius: 10,
    width: '100%',
    alignItems: 'center',
    marginTop: 30,
  },
  logoutButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontFamily: 'FredokaOne',
  },
});

export default DashboardScreen;
=== ./src/screens/HomeScreen.js ===
import React, { useEffect, useState } from 'react';
import { 
  View, Text, TouchableOpacity, StyleSheet, 
  ImageBackground, Image, Alert 
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage'; // 📌 Stockage local pour gérer le token utilisateur

// 📌 Écran d'accueil (HomeScreen)
const HomeScreen = ({ navigation }) => {
  // ✅ État pour stocker les informations du profil utilisateur
  const [user, setUser] = useState(null);

  // 🎯 Effet qui s'exécute au montage du composant (vérification du token et récupération du profil)
  useEffect(() => {
    const fetchUserProfile = async () => {
      try {
        // 🔑 Récupérer le token de connexion stocké
        const token = await AsyncStorage.getItem('token');
        console.log("Token récupéré dans HomeScreen :", token);
        
        if (!token) {
          console.log("Aucun token trouvé, redirection vers Login...");
          navigation.reset({ index: 0, routes: [{ name: 'Login' }] }); // 🚪 Redirige vers l'écran de connexion si pas de token
          return;
        }

        // 🔍 Vérification du token en appelant l'API backend
        const response = await fetch('https://backend-city-connect.vercel.app/auth/profile', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`, // 🔑 Ajoute le token dans les headers
            'Content-Type': 'application/json',
          },
        });

        const data = await response.json(); // 📥 Récupération de la réponse du serveur
        console.log("Réponse de /auth/profile :", data);

        if (!response.ok) {
          console.log("Token invalide, suppression et redirection...");
          await AsyncStorage.removeItem('token'); // 🚫 Supprimer un token invalide
          navigation.reset({ index: 0, routes: [{ name: 'Login' }] }); // 🚪 Redirige vers l'écran de connexion
        } else {
          setUser(data); // ✅ Stocker les informations du profil utilisateur
        }
        
      } catch (error) {
        console.error("❌ Erreur lors de la récupération du profil :", error);
      }
    };

    fetchUserProfile();
  }, []); // 🔄 S'exécute une seule fois lors du premier affichage

  // 🔐 Fonction pour gérer la déconnexion
  const handleLogout = async () => {
    await AsyncStorage.removeItem('token'); // 🚫 Supprime le token de connexion
    navigation.navigate('Login'); // 🚪 Redirige vers la page de connexion
  };

  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <View style={styles.container}>
        {/* 🏙️ Logo et titre de l'application */}
        <Image source={require('../../assets/logo.png')} style={styles.logo} />
        <Text style={styles.title}>CityConnect</Text>
        <Text style={styles.subtitle}>DÉCOUVRE LA VILLE AVEC UN HABITANT</Text>

        {/* 👤 Affichage des informations de l'utilisateur si connecté */}
        {user ? (
          <>
            <Text style={styles.welcomeText}>Bienvenue, {user.username} !</Text>
            <Text style={styles.emailText}>{user.email}</Text>
          </>
        ) : (
          <Text style={styles.loadingText}>Chargement du profil...</Text> // ⏳ Affiche un message si les données sont en cours de chargement
        )}

        {/* 🔴 Bouton de déconnexion */}
        <TouchableOpacity style={styles.button} onPress={handleLogout}>
          <Text style={styles.buttonText}>Déconnexion</Text>
        </TouchableOpacity>
      </View>
    </ImageBackground>
  );
};
const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    alignItems: 'center',
  },
  logo: {
    width: 80,
    height: 80,
    marginBottom: 20,
  },
  title: {
    fontSize: 26,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 30,
    textAlign: 'center',
  },
  welcomeText: {
    fontSize: 18,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 10,
  },
  emailText: {
    fontSize: 16,
    fontFamily: 'FredokaOne',
    color: '#555',
    marginBottom: 20,
  },
  loadingText: {
    fontSize: 16,
    fontFamily: 'FredokaOne',
    color: '#999',
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#2D2A6E',
    padding: 15,
    borderRadius: 10,
    width: '100%',
    alignItems: 'center',
    marginVertical: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontFamily: 'FredokaOne',
  },
});

export default HomeScreen;
=== ./src/screens/LoginScreen.js ===
import React, { useState } from 'react';
import { 
  View, Text, TextInput, TouchableOpacity, StyleSheet, 
  ImageBackground, Image, Alert 
} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage'; // 📌 Stockage local pour gérer le token utilisateur

// 📌 Écran de connexion (Login)
const LoginScreen = ({ navigation }) => {
  // ✅ États pour stocker les informations saisies par l'utilisateur
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // 🔐 Fonction pour gérer la connexion
  const handleLogin = async () => {
    try {
        // 🔗 Requête vers l'API pour tenter de se connecter
        const response = await fetch('https://backend-city-connect.vercel.app/auth/login', {
            method: 'POST', // 📩 Envoi des données via une requête POST
            headers: { 'Content-Type': 'application/json' }, // 📌 Indique que les données envoyées sont en JSON
            body: JSON.stringify({ email, password }), // 🔒 Envoi des identifiants utilisateur
        });

        const data = await response.json(); // 📥 Récupération de la réponse du serveur
        console.log("Réponse du backend :", data); // 🖥️ Affiche la réponse complète du serveur dans la console

        if (response.ok) {
            // 🔑 Stocker le token dans AsyncStorage pour les futures requêtes
            await AsyncStorage.setItem('token', data.token);
            console.log("Token stocké :", await AsyncStorage.getItem('token')); // 🔍 Vérifie que le token est bien enregistré

            // 🚀 Redirection vers le tableau de bord après connexion
            navigation.reset({
                index: 0,
                routes: [{ name: 'Dashboard' }],
            });
        } else {
            // ⚠️ Affiche une alerte si la connexion échoue
            Alert.alert("Erreur de connexion", data.message);
        }
    } catch (error) {
        console.error('❌ Erreur lors de la connexion:', error);
        Alert.alert("Erreur", "Impossible de se connecter. Vérifiez votre connexion internet.");
    }
  };

  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <View style={styles.container}>
        {/* 🏙️ Logo et titre de l'application */}
        <Image source={require('../../assets/logo.png')} style={styles.logo} />
        <Text style={styles.title}>CityConnect</Text>
        <Text style={styles.subtitle}>DÉCOUVRE LA VILLE AVEC UN HABITANT</Text>

        {/* 📧 Champ de saisie pour l'email */}
        <TextInput 
          placeholder="Email" 
          style={styles.input} 
          value={email} 
          onChangeText={setEmail} 
          keyboardType="email-address" // 📌 Clavier adapté pour les adresses email
        />

        {/* 🔒 Champ de saisie pour le mot de passe */}
        <TextInput 
          placeholder="Mot de passe" 
          style={styles.input} 
          secureTextEntry // 👀 Cache le mot de passe en mode sécurisé
          value={password} 
          onChangeText={setPassword} 
        />

        {/* 🟢 Bouton pour se connecter */}
        <TouchableOpacity style={styles.button} onPress={handleLogin}>
          <Text style={styles.buttonText}>Se connecter</Text>
        </TouchableOpacity>

        {/* 🔵 Bouton de connexion via Google (non fonctionnel pour l'instant) */}
        <TouchableOpacity style={styles.googleButton}>
          <Text style={styles.googleButtonText}>Sign up with Google</Text>
        </TouchableOpacity>

        {/* 📌 Lien pour aller à la page d'inscription */}
        <TouchableOpacity onPress={() => navigation.navigate('Register')}>
          <Text style={styles.linkText}>Pas encore de compte ? Inscris-toi</Text>
        </TouchableOpacity>
      </View>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  container: {
    width: '90%',
    alignItems: 'center',
  },
  logo: {
    width: 150,
    height: 150,
    marginBottom: 20,
  },
  title: {
    fontSize: 26,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
  },
  subtitle: {
    fontSize: 14,
    color: '#666',
    fontFamily: 'FredokaOne',
    marginBottom: 30,
    textAlign: 'center',
  },
  input: {
    width: '100%',
    padding: 12,
    marginVertical: 10,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 10,
    backgroundColor: 'rgba(255,255,255,0.8)',
  },
  button: {
    backgroundColor: '#2D2A6E',
    fontFamily: 'FredokaOne',
    padding: 15,
    borderRadius: 10,
    width: '100%',
    alignItems: 'center',
    marginVertical: 10,
  },
  buttonText: {
    color: '#FFFFFF',
    fontFamily: 'FredokaOne',
    fontSize: 16,
  },
  googleButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 10,
    padding: 12,
    width: '100%',
    marginTop: 20,
    backgroundColor: '#fff',
  },
  googleButtonText: {
    fontFamily: 'FredokaOne',
    fontSize: 16,
    color: '#000',
  },
  linkText: {
    marginTop: 15,
    color: '#2D2A6E',
    fontFamily: 'FredokaOne',
  },
});

export default LoginScreen;
=== ./src/screens/MessageScreen.js ===
import React, { useState } from 'react';
import { 
  View, Text, TextInput, TouchableOpacity, FlatList, StyleSheet, KeyboardAvoidingView, Platform 
} from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import { Ionicons } from '@expo/vector-icons';
import Header from '../components/Header';

const MessageScreen = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { conversationId, conversationName = "Conversation", exampleMessages = [] } = route.params || {};

  const [messages, setMessages] = useState(exampleMessages);
  const [newMessage, setNewMessage] = useState('');

  const handleGoBack = () => {
    navigation.goBack();
  };

  const getCurrentTime = () => {
    const now = new Date();
    return now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  const handleSendMessage = () => {
    if (newMessage.trim() === '') return;
    setMessages((prevMessages) => [
      ...prevMessages,
      { id: Date.now().toString(), text: newMessage, sender: 'me', senderName: 'Moi', time: getCurrentTime() },
    ]);
    setNewMessage('');
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
       
      <View style={{ flexDirection: 'row', alignItems: 'center' }}>
      <TouchableOpacity 
  onPress={() => {
    console.log("Bouton de retour pressé");
    navigation.goBack();
  }} 
  style={styles.backButton}
>
  <Ionicons name="arrow-back" size={24} color="#20135B" />
</TouchableOpacity>
        <Header />
      </View>
      <Text style={styles.title}>{conversationName}</Text>

      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View>
            {item.sender === 'other' && (
              <Text style={styles.senderName}>{item.senderName}</Text>
            )}
            <View
              style={[
                styles.messageBubble,
                item.sender === 'me' ? styles.myMessage : styles.otherMessage,
              ]}
            >
              <Text style={styles.messageText}>{item.text}</Text>
              <Text style={styles.timeText}>{item.time}</Text>
            </View>
          </View>
        )}
        contentContainerStyle={styles.messagesContainer}
      />

      <View style={styles.inputContainer}>
        <TextInput
          style={styles.textInput}
          placeholder="Écrire un message..."
          value={newMessage}
          onChangeText={setNewMessage}
        />
        <TouchableOpacity style={styles.sendButton} onPress={handleSendMessage}>
          <Text style={styles.sendButtonText}>Envoyer</Text>
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};


const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  messagesContainer: {
    padding: 10,
    paddingTop: 140,
  },
  backButton: {
    position: 'absolute',
    top: 70,
    left: 20,
    zIndex: 21,
    padding: 5,
    
  },
  senderName: {
    fontSize: 12,
    color: '#555',
    marginBottom: 2,
    marginLeft: 5,
  },
  messageBubble: {
    maxWidth: '80%',
    padding: 10,
    borderRadius: 10,
    marginBottom: 10,
  },
  myMessage: {
    alignSelf: 'flex-end',
    backgroundColor: '#F1F0F0',
    borderWidth: 1,
    borderColor: '#20135B',
  },
  otherMessage: {
    alignSelf: 'flex-start',
    backgroundColor: '#E2DFEE',
    borderWidth: 1,
    borderColor: '#20135B',
  },
  messageText: {
    color: '#20135B',
    fontFamily: 'FredokaOne',
    fontSize: '16'
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
    borderTopWidth: 1,
    borderTopColor: '#ddd',
    backgroundColor: '#fff',
  },
  textInput: {
    flex: 1,
    height: 40,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 20,
    paddingHorizontal: 10,
    marginRight: 10,
    backgroundColor: '#f9f9f9',
  },
  sendButton: {
    backgroundColor: '#20135B',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 20,
  },
  sendButtonText: {
    color: '#fff',
    fontFamily: 'FredokaOne',
  },
  timeText: {
    fontSize: 10,
    color: '#888',
    alignSelf: 'flex-end',
    marginTop: 5,
  },
});

export default MessageScreen;
=== ./src/screens/ActivityScreen.js ===
import React, { useState, useEffect } from 'react';
import { 
  View, Text, TouchableOpacity, StyleSheet, ImageBackground, ScrollView, Alert 
} from 'react-native';
import Header from '../components/Header';
import * as Location from 'expo-location';

const activities = [
  { id: 1, title: 'Sport', image: require('../../assets/sport.jpg') },
  { id: 2, title: 'Culturel', image: require('../../assets/culturel.jpg') },
  { id: 3, title: 'Sorties', image: require('../../assets/sorties.jpg') },
  { id: 4, title: 'Culinaire', image: require('../../assets/culinaire.jpg') },
];

const ActivityScreen = ({ navigation }) => {
  const [userLocation, setUserLocation] = useState(null);

  // Récupérer la localisation dès le montage de l'écran
  useEffect(() => {
    (async () => {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        Alert.alert('Permission refusée', 'La localisation est nécessaire pour cette fonctionnalité.');
        return;
      }
      const location = await Location.getCurrentPositionAsync({});
      setUserLocation(location.coords);
    })();
  }, []);

  return (
    <ImageBackground source={require('../../assets/background.png')} style={styles.background}>
      <Header />
      {/* Pour éviter le chevauchement avec le Header */}
      <View style={{ marginTop: 60 }} />
      <ScrollView contentContainerStyle={styles.container}>
        <Text style={styles.title}>Activité</Text>
        {activities.map(activity => (
          <TouchableOpacity
            key={activity.id}
            style={styles.activityCard}
            onPress={() =>
              navigation.navigate('Carte', {
                filter: 'activity', 
                category: activity.title, 
                userLocation,
              })
            }
          >
            <ImageBackground 
              source={activity.image} 
              style={styles.image} 
              imageStyle={{ borderRadius: 10 }}
            >
              <View style={styles.overlay}>
                <Text style={styles.activityText}>{activity.title}</Text>
              </View>
            </ImageBackground>
          </TouchableOpacity>
        ))}
        
      </ScrollView>
    </ImageBackground>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
    width: '100%',
    height: '100%',
  },
  container: {
    flexGrow: 1,
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 30,
    width: '100%',
  },
  title: {
    fontSize: 28,
    fontFamily: 'FredokaOne',
    color: '#2D2A6E',
    marginBottom: 20,
    textAlign: 'center',
  },
  activityCard: {
    width: '90%',
    height: 150,
    borderRadius: 10,
    overflow: 'hidden',
    marginBottom: 15,
    alignSelf: 'center',
  },
  image: {
    width: '100%', 
    height: '100%',
    justifyContent: 'flex-end',
    alignItems: 'center',
  },
  overlay: {
    width: '100%',
    backgroundColor: 'rgba(0,0,0,0.3)',
    paddingVertical: 10,
    alignItems: 'center',
  },
  activityText: {
    fontSize: 24,
    fontFamily: 'FredokaOne',
    color: 'white',
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#2D2A6E',
    padding: 15,
    borderRadius: 10,
    marginTop: 20,
    alignSelf: 'center',
  },
  buttonText: {
    color: '#fff',
    fontFamily: 'FredokaOne',
    fontSize: 16,
  },
});

export default ActivityScreen;
=== ./src/components/Header.js ===
import React from 'react';
import { View, Text, Image, StyleSheet, StatusBar, Platform } from 'react-native';

const Header = () => {
  return (
    <View style={styles.container}>
      <View style={styles.innerContainer}>
        <Image
          source={require('../../assets/logo.png')} // Remplacez par le chemin vers votre logo
          style={styles.logo}
        />
        <Text style={styles.title}>City Connect</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    position: 'absolute', // Position absolue pour coller au haut de l'écran
    top: 0,
    left: 0,
    right: 0,
    backgroundColor: '#f8f9fa',
    paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 40, // Ajustement pour Android
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
    zIndex: 1, // Assurez que le header est au-dessus des autres éléments
  },
  innerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    height: 80, // Hauteur fixe du header
    paddingHorizontal: 10,
  },
  logo: {
    width: 70, // Taille réduite du logo pour un meilleur alignement
    height: 50,
    resizeMode: 'contain',
    marginRight: 1, // Espacement entre le logo et le texte
  },
  title: {
    fontSize: 32,
    fontFamily: 'FredokaOne',
    color: '#20135B',
  },
});

export default Header;
=== ./src/components/CustomText.js ===
import React from 'react';
import { Text, StyleSheet } from 'react-native';

const CustomText = ({ style, children }) => {
  return <Text style={[styles.defaultText, style]}>{children}</Text>;
};

const styles = StyleSheet.create({
  defaultText: {
    fontFamily: 'FredokaOne',
  },
});

export default CustomText;
